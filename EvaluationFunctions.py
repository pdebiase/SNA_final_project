# Importing packages
from functools import reduce
import operator


#Fraction of information cascades and contamination events detected by the selected nodes
def detection_likelihood(outbreak_simulation, placement, inverse=True):
    '''
    For a given run or multiple runs, calculate the placement score with detection likelihood as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :param inverse: if inverse is set to True, return 1 - detection likelihood score, such that a lower score is a better score
    :return: Returns the average detection likelihood score (between 0 and 1) over all runs
    '''
    # If any node in the placement got infeceted then we detected the outbreak
    if list(set(placement) & set(reduce(operator.concat, outbreak_simulation))):
        detection = 1
    else:
        detection = 0
    if inverse:
        return 1-detection
    
    else:
          return detection

def detection_time(outbreak_simulation, placement):
    '''
    For a given run or multiple runs, calculate the placement score with detection time as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average detection time score over all runs
    '''  
    # Creating a set for the placement
    set_placement = set(placement)
    # If any node in the placement got infeceted then we detected the outbreak and we need to check the detection time
    intersection = list(set_placement & set(reduce(operator.concat, outbreak_simulation)))
    if intersection:
        # For each step and nodes infected in this step we are going to check if the placement detected it
        for step,nodes in enumerate(outbreak_simulation):
            # If any element in the intersection is in this set of nodes, than it was detected at this time step
            if list(set(intersection) & set(nodes)):
                output = step
                break
    # If not detected, than the detection time is the max penalty
    else:
        max_penalty = len(outbreak_simulation)
        output = max_penalty
    return output

def population_affected(outbreak_simulation, placement):
    '''
    For a given run or multiple runs, calculate the placement score with population affected as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average population affected score over all runs
    '''
          
    # Creating a set for the placement
    set_placement = set(placement)
    output = 0
    # If any node in the placement got infeceted then we detected the outbreak and we need to check the population affected
    intersection = list(set_placement & set(reduce(operator.concat, outbreak_simulation)))
    if intersection:
        # For each step and nodes infected in this step we are going to check if the placement detected it
        for nodes in outbreak_simulation:
            # If any element in the intersection is in this set of nodes, then it was detected at this time step
            # and we can finish by appending the population affected to the output and breaking the run
            if list(set(intersection) & set(nodes)):
                break
            else:
        	# If not, then we need to sum the non-detected nodes to the pop affected
            	output += len(nodes)
    # If not detected, than the pop affected is the size of the outbreak
        else:
            output = len(reduce(operator.concat, outbreak_simulation))
    return output


#########JUST TO TEST ########
#import pickle
#import os
#path = "C:\\Users\\pvbia\\EPA - Delft\\2o Year\\Social Network\\Final Project\\SNA_final_project-master"
#os.chdir(path)
#os.getcwd()
#file = "1jazz_outbreaks.data"
#with open(file, 'rb') as filehandle:
#    # read the data as binary data stream
#    data = pickle.load(filehandle)
#
#placement = [160]
#
#detection_likelihood(data[0], placement) 
#
#detection_time(data[0], placement) 
#
#population_affected(data[0], placement) 




