import numpy as np
import functools
#Fraction of information cascades and contamination events detected by the selected nodes
def detection_likelihood(run, placement, inverse=True):
    '''
    For a given run or multiple runs, calculate the placement score with detection likelihood as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :param inverse: if inverse is set to True, return 1 - detection likelihood score, such that a lower score is a better score
    :return: Returns the average detection likelihood score (between 0 and 1) over all runs
    '''
    dl = 0

    for node in placement:
        if node in run[0]:
            dl = 1
            break

    if inverse:
        return 1-dl
    else:
        return dl

def detection_time(run, placement):
    '''
    For a given run or multiple runs, calculate the placement score with detection time as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average detection time score over all runs
    '''
         
    detected = False
    dt = {}
    for node in placement:
        if node in run[0]:
            detected = True 
            dt.update({node:run[0][node]})        
    if detected:
        return (dt[min(dt.keys(), key=(lambda k: dt[k]))]/len(run[1]))
    else:
        return 1

def population_affected(run, placement):
    '''
    For a given run or multiple runs, calculate the placement score with population affected as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average population affected score over all runs
    '''
          
    pa = 0
    detected = False   
    dt = -1
    min_dt = np.inf

    for node in placement:
        if node in run[0]:
            dt = run[0][node] 
            detected=True
            if dt < min_dt:
                min_dt = dt
    pa = 0

    if detected:
        for i in range(0, min_dt):
            pa += len(run[1][i])
    else:
        pa = len(run[0])
    
    return (pa/len(run[0]))

#Fraction of information cascades and contamination events detected by the selected nodes
def detection_likelihood_mean(outbreak_simulations, placement, inverse=True):
    '''
    For a given run or multiple runs, calculate the placement score with detection likelihood as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :param inverse: if inverse is set to True, return 1 - detection likelihood score, such that a lower score is a better score
    :return: Returns the average detection likelihood score (between 0 and 1) over all runs
    '''
    function = functools.partial(detection_likelihood,placement=placement)

    return np.mean(list(map(function,outbreak_simulations)))

def detection_time_mean(outbreak_simulations, placement):
    '''
    For a given run or multiple runs, calculate the placement score with detection time as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average detection time score over all runs
    '''
    function = functools.partial(detection_time,placement=placement)

    return np.mean(list(map(function,outbreak_simulations)))

def population_affected_mean(outbreak_simulations, placement):
    '''
    For a given run or multiple runs, calculate the placement score with population affected as objective
    :param outbreak_simulations: outbreak simulation data generated by simulate_outbreak
    :param placement: solution set of nodes to calculate score for
    :return: Returns the average population affected score over all runs
    '''
    function = functools.partial(population_affected,placement=placement)

    return np.mean(list(map(function,outbreak_simulations)))


##########JUST TO TEST ########
#import os
#import pickle
#path = "C:\\Users\\pvbia\\EPA - Delft\\2o Year\\Social Network\\Final Project\\SNA_final_project (v optimized)"
#os.chdir(path)
#os.getcwd()
#file = "1jazz_outbreaks.data"
#with open(file, 'rb') as filehandle:
#    # read the data as binary data stream
#    data = pickle.load(filehandle)
#
#placement = [164]
#
#detection_likelihood(data[3], placement) 
#
#detection_time(data[3], placement) 
#
#population_affected(data[3], placement) 



